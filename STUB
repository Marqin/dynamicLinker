/*
 *  Copyright (c) Hubert Jarosz. All rights reserved.
 *  Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

#if not defined (__unix__) && not defined(__unix) && not defined (unix) && ( (not defined (__APPLE__) || not defined (__MACH__)) )
  #error THIS SOFTWARE IS ONLY FOR UNIX-LIKE SYSTEMS!
#endif

#pragma once

#include <memory>
#include <iostream>
#include <dlfcn.h>
#include <functional>
#include <unordered_map>

namespace dynamicLinker {

  class _void {
  private:
    void * myself = nullptr;
  public:
    _void( void * ptr ) : myself(ptr) {}
    ~_void() {
      if( myself != nullptr )
        free(myself);
    }
    void * ptr() const {
      return myself;
    }
    void null() {
      myself = nullptr;
    }
  };

  class dynamicLinker {
  private:
    bool safe = true;
    std::string libPath = "";
    std::unique_ptr<_void> lib = nullptr;
    std::unordered_map<std::string, dynamicSymbol> symbols = std::unordered_map<std::string, dynamicSymbol>();
  public:
    dynamicLinker( std::string );
    dynamicLinker( std::string, bool );
    ~dynamicLinker();
    bool open();
    bool explicitClose();
    //template<typename T> std::function<T> getFunction( std::string name ) {
    shared_ptr<dynamicSymbol> getSymbol( std::string name ) {
      symbols.emplace( name, dynamicSymbol(name) )
      return shared_ptr<dynamicSymbol>( symbols[""] )
      //std::function<T>(reinterpret_cast< T * >(  ));
    }

    class dynamicSymbol {
    private:
      int cnt = 0;
      std::unique_ptr<_void> symbol;
    public:
      dynamicSymbol( std::string name ) {
        symbol = _void(dlsym( lib->ptr(), name.c_str() ))
      }
      ~dynamicSymbol() {

      }
    }
  };
};
